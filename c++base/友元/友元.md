### 定义

**友元**（friend）允许一个函数或类访问另一个类的私有（private）和保护（protected）成员。

友元关系是非继承的，不可传递的，而且是单向的。

### 思考

问：我想在一个特定的函数中，访问一个类的私有成员，怎么办。

答：在类中把那个函数设置成元友函数，

### 友元函数

友元函数可以在类的内部声明，它能够访问该类的所有私有和保护成员。

友元函数不属于类的成员，所以它不遵循类的访问权限。

**示例**：

```cpp
class MyClass {
private:
    int privateData;

public:
    MyClass() : privateData(10) {}
    // 声明友元函数
    friend void printPrivateData(MyClass &obj);
};

// 定义友元函数
void printPrivateData(MyClass &obj) {
    std::cout << "Private Data: " << obj.privateData << std::endl;
}

int main() {
    MyClass obj;
    printPrivateData(obj); // 能够访问并打印privateData
    return 0;
}
```

### 2. 友元类

一个类可以被声明为另一个类的友元，这意味着这个友元类可以访问原类的所有私有和保护成员。

**示例**：

```cpp
class MyClass {
private:
    int privateData;

public:
    MyClass() : privateData(10) {}

    // 声明FriendClass为友元类
    friend class FriendClass;
};

class FriendClass {
public:
    void printData(MyClass &obj) {
        std::cout << "Private Data: " << obj.privateData << std::endl;
    }
};

int main() {
    MyClass obj;
    FriendClass friendObj;
    friendObj.printData(obj);
    return 0;
}
```

### 3. 友元的作用

- **提高灵活性**：友元允许非成员函数或类访问私有数据，这在某些情况下可以提供更灵活的设计方案。
- **简化代码**：在需要跨越类的界限进行通信时，友元可以避免繁琐的getter和setter方法。
- **流操作符重载**：在C++中，流操作符（如 `<<`和 `>>`）通常作为友元函数定义，这样可以访问类的私有成员，实现更自然的输入输出格式。

### 注意事项

- 友元关系不是互惠的，即如果 `A`是 `B`的友元，`B`并不自动成为 `A`的友元。
- 友元关系不传递，即如果 `A`是 `B`的友元，`B`是 `C`的友元，`A`并不会自动成为 `C`的友元。
- 使用友元时应当谨慎，因为过度使用会破坏封装性，降低代码的安全性和可维护性。

总的来说，友元在C++中是一种强大的工具，它能够在保持封装性的同时，提供额外的灵活性和功能。然而，由于它破坏了严格的封装原则，应当在确实需要时才使用。
