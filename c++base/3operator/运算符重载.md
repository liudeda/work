# C++运算符重载教程

**运算符重载**，就是对已有的运算符重新进行定义，赋予其另一种功能，以适应不同的数据类型
**运算符重载的目的**：简化操作  让已有的运算符 适应适应不同的数据类型。
**语法**：函数的名字由关键字operator及其紧跟的运算符组成
**比如**：重载+运算符 ==>operator+    重载=号运算 ==>operator= 
**注意**：重载运算符 不要更改 运算符的本质操作（+是数据的相加  不要重载成相减）

### 可重载的运算符

大多数运算符都可以重载，但有少数几个例外，如 `::`、`.`、`.*`、`sizeof`、`typeid`、三目运算符等。

## 运算符重载基础

### 语法

运算符重载可以通过成员函数或非成员函数（友元函数）实现。选择哪种形式取决于运算符的性质。

#### 成员函数形式

```cpp
class MyClass {
public:
    MyClass operator+(const MyClass& other) const {
        // 实现加法逻辑
    }
};
```

#### 非成员函数形式（通常为友元函数）

```cpp
class MyClass {
    friend MyClass operator+(const MyClass& a, const MyClass& b);
};

MyClass operator+(const MyClass& a, const MyClass& b) {
    // 实现加法逻辑
}
```

### 示例：复数类的加法运算符重载

假设有一个复数类 `Complex`，我们重载加法运算符以支持复数相加。

```cpp
#include <iostream>

class Complex {
    double real, imag;
public:
    Complex(double r = 0.0, double i = 0.0) : real(r), imag(i) {}

    // 成员函数形式重载加法运算符
    Complex operator+(const Complex& c) const {
        return Complex(real + c.real, imag + c.imag);
    }

    void display() const { std::cout << real << " + " << imag << "i\n"; }
};

int main() {
    Complex c1(3, 4), c2(1, -2), c3 = c1 + c2; // 使用重载的加法运算符
    c3.display(); // 输出: 4 + 2i
    return 0;
}
```

## 注意事项与最佳实践

- **保持运算符行为的自然性**：重载后的运算符行为应尽可能符合用户的直觉。
- **避免意外的副作用**：运算符重载应尽量保持纯函数性质，避免修改操作数。
- **注意运算符的优先级和结合性**：虽然不能更改，但在设计时需考虑这些特性的影响。
- **适度使用**：过度重载运算符可能会使代码难以理解，仅在真正提高代码清晰度时才进行重载。

在C++中，逻辑与运算符 `&&`和逻辑或运算符 `||`是不可以被常规重载的，因为它们具有特殊的短路求值（short-circuit evaluation）特性，即如果左边的表达式已经能够决定整个逻辑表达式的值，右边的表达式将不会被评估。这是为了效率和安全性考虑，特别是当右侧表达式涉及到有副作用的操作时。

### 为何不建议重载 `&&`和 `||`

1. **短路求值特性**：这两个运算符的设计初衷就是利用短路特性来优化性能和避免不必要的计算。重载它们会破坏这一机制，可能导致不可预料的行为或性能损失。
2. **副作用控制**：由于短路特性，程序员有时会依赖这种行为来控制程序流，避免某些可能产生副作用的表达式被执行。允许重载可能会导致这些依赖关系变得模糊，增加代码的错误风险。
3. **语言设计哲学**：C++设计者选择不允许重载 `&&`和 `||`，可能是出于对语言一致性和安全性的考虑，避免引入过于复杂的语义，保持语言的清晰度。

## 成员函数重载和全局函数重载怎么选择

### 可以修改左操作数的情况（使用成员函数重载）:

1. **拥有类的控制权**：当你对类的源代码有完全控制权，并且修改类的实例状态是合理且期望的行为时，可以选择在类内部重载运算符作为成员函数。
2. **修改实例状态**：如果运算符的逻辑要求直接改变调用该运算符的对象的状态（即左操作数），通常会采用成员函数重载。例如，`+=`、`-=`等累加或减去操作符。
3. **保持封装性**：当重载的运算符逻辑紧密关联于类的内部实现，且需要访问类的私有或保护成员时，成员函数形式更合适，因为它可以直接访问这些成员，保持了类的封装性。

### 不宜或不能直接修改左操作数的情况（使用友元函数或全局函数重载）:

1. **保持操作符的中立性**：如果运算符的逻辑不应直接改变任何参与运算的对象状态，而是生成一个新的结果，比如加法 `+`、乘法 `*`等，通常会倾向于不修改左操作数，此时可能选择非成员函数重载。
2. **操作数类型限制**：当一个操作数不是自定义类型，而是内置类型或标准库类型（如 `int`、`std::string`、`std::ostream`等），你无法直接修改这些类型的定义，因此必须使用全局函数或友元函数来重载运算符。
3. **跨类交互**：在某些情况下，两个不同类之间的运算逻辑可能不适合放在任何一个类内部定义，尤其是当两个类都可能作为操作数出现时。此时，全局函数或友元函数提供了一种更中立的重载方式。

总结来说，是否修改左操作数取决于操作符的语义、类的设计原则以及对类实例状态管理的需求。在设计时，重要的是确保运算符的重载遵循直观性、一致性和效率原则，同时维护良好的面向对象设计实践。

## 例程说明

### 1.cpp是计算向量和的例子
