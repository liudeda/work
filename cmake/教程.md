# 最简单的cmake工程helloword

1. **cmake_minimum_required(VERSION 3.10)**:
   - 这行命令指定了CMake的最低版本要求。在这个例子中，CMakeLists.txt文件是为CMake 3.10或更高版本编写的。这意味着，如果你尝试使用低于3.10版本的CMake来构建这个项目，CMake将会报错，因为它不支持这个CMakeLists.txt文件中使用的某些特性或命令。
2. **project (hello_cmake)**:
   - 这行命令设置了项目的名称，在这个例子中，项目名称被设置为`hello_cmake`。这个名称将用于生成的目标文件（如可执行文件或库文件）的前缀，除非在`add_executable`或`add_library`等命令中明确指定了不同的名称。此外，这个名称也会被用于一些CMake变量和缓存条目的命名。
3. **add_executable(hello_cmake main.cpp)**:
   - 这行命令添加了一个可执行目标到项目中。目标名称（在这个例子中是`hello_cmake`）与项目名称相同，但这并不是必须的；你可以为可执行文件指定任何你喜欢的名称。`main.cpp`是源文件列表，CMake将编译这些源文件来生成可执行文件。在这个例子中，只有一个源文件`main.cpp`，但你可以通过添加更多的文件名来扩展这个列表，CMake会编译所有列出的源文件来生成可执行文件。

cmake常用指令

-S 指定源码目录

-B指定生成文件路径

cmake --build .   编译，使用生成文件，编译

```
PS C:\work\cmake\A-hello-cmake> cmake -S . -B .\build\
-- Configuring done (0.2s)
-- Generating done (0.0s)
-- Build files have been written to: C:/work/cmake/A-hello-cmake/build
PS C:\work\cmake\A-hello-cmake> cmake --build .\build\  
[ 50%] Building CXX object CMakeFiles/hello_cmake.dir/main.cpp.obj
[100%] Linking CXX executable hello_cmake.exe
[100%] Built target hello_cmake
PS C:\work\cmake\A-hello-cmake> .\build\hello_cmake.exe 9    
argv[0] = C:\work\cmake\A-hello-cmake\build\hello_cmake.exe
argv[1] = 9
Hello CMake!
PS C:\work\cmake\A-hello-cmake> 
```

## 多目录的工程怎么写cmake文件

目录结构

```
B-hello-headers
│  │  CMakeLists.txt 
│  ├─build
│  ├─include
│  │      Hello.h
│  │      
│  └─src
│          Hello.cpp
│          main.cpp
```

1. **`add_executable(hello_headers "src/Hello.cpp" "src/main.cpp")`**

   这行代码告诉CMake，我们希望创建一个可执行文件（executable），并将其命名为`hello_headers`。这个可执行文件将由`src/Hello.cpp`和`src/main.cpp`这两个源文件编译生成。在CMake中，`add_executable`命令用于定义一个可执行文件目标，并列出所有参与编译的源文件。

2. **`target_include_directories(hello_headers PRIVATE ${PROJECT_SOURCE_DIR}/include)`**

   这行代码用于指定在编译`hello_headers`这个可执行文件时，应该包含哪些目录的头文件。这里，它被设置为包含`${PROJECT_SOURCE_DIR}/include`目录。

   - `target_include_directories`是CMake中用于向目标（在这里是可执行文件`hello_headers`）添加包含目录的命令。
   - `hello_headers`是指定的目标名称，即前面通过`add_executable`定义的可执行文件。
   - `PRIVATE`关键字指定了这些包含目录的可见性。在这个例子中，`PRIVATE`意味着这些包含目录仅对`hello_headers`这个目标可见，不会被它的依赖项或其他目标继承。后面会详细讲，此时不关心
   - `${PROJECT_SOURCE_DIR}`是一个CMake变量，它自动设置为当前CMake项目的根目录的路径。因此，`${PROJECT_SOURCE_DIR}/include`指的是项目根目录下的`include`子目录。

# 多目录工程，子模块的方式怎么实现

目录结构

```


├─C-hello-headerslib
│  │  CMakeLists.txt
│  │  main.cpp
│  │  
│  ├─build
│  └─hellolibdir
│          CMakeLists.txt
│          hello.cpp
│          hello.h
```

1. **add_subdirectory(hellolibdir)**: 这行代码向项目添加了一个子目录`hellolibdir`。CMake会在构建过程中进入到这个子目录，并查找那里的CMakeLists.txt文件（如果存在的话）。这通常用于将库或其他可重用的组件组织到单独的子目录中。在这个例子中，我们可以推测`hellolibdir`目录包含了一个库（可能名为`hellolib`）的源代码和相应的CMakeLists.txt文件。

2. **add_executable(${PROJECT_NAME} main.cpp)**: 这行代码创建了一个可执行文件目标，其名称与项目名称相同（通过`${PROJECT_NAME}`宏获取），并指定`main.cpp`作为源文件。这意味着CMake将编译`main.cpp`并链接必要的库（如果有的话）来生成可执行文件。

3. **target_link_libraries(${PROJECT_NAME} PUBLIC hellolib)**: 这行代码将名为`hellolib`的库链接到之前创建的可执行文件目标（即项目名称`hello_headers`）。`PUBLIC`关键字指定了`hellolib`不仅是目标`hello_headers`的链接库，而且任何链接到`hello_headers`的库或可执行文件也应该链接到`hellolib`。

4. 

   ```
   target_include_directories(${PROJECT_NAME} PRIVATE ${CMAKE_CURRENT_SOURCE_DIR}/hellolibdir)
   ```

   这行代码向`hello_headers`目标添加了私有包含目录。`PRIVATE`关键字意味着这些包含目录仅对`hello_headers`目标本身可见，不会传递给链接到`hello_headers`的任何其他目标。`${CMAKE_CURRENT_SOURCE_DIR}`是一个CMake变量，表示当前CMakeLists.txt文件所在的目录，因此`${CMAKE_CURRENT_SOURCE_DIR}/hellolibdir`就是`hellolibdir`子目录的绝对路径。这通常用于指定库的头文件所在的目录，以便编译器可以找到它们。



# 怎么使用cmake生成宏定义

当我们想在代码中使用宏控制编译文件，或者使用哪个算法时，可以在cmake生成宏定义

```cmake
set (CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -DEX2" )
target_compile_definitions(cmake_examples_compile_flags PRIVATE EX3 ) # 局部定义  
add_definitions(-DEX4)#全局定义
```

- `-DEX2`通过修改`CMAKE_CXX_FLAGS`被全局应用于所有C++源文件。
- `EX3`是一个私有的编译定义，仅对`cmake_examples_compile_flags`目标有效。
- `-DEX4`通过`add_definitions`被全局应用于所有目标。

# Step5 生成器表达式

## 资源

- [`cmake-generator-expressions(7)`](https://cmake.org/cmake/help/latest/manual/cmake-generator-expressions.7.html#manual:cmake-generator-expressions(7))
- [`cmake_minimum_required()`](https://cmake.org/cmake/help/latest/command/cmake_minimum_required.html#command:cmake_minimum_required)
- [`set()`](https://cmake.org/cmake/help/latest/command/set.html#command:set)
- [`target_compile_options()`](https://cmake.org/cmake/help/latest/command/target_compile_options.html#command:target_compile_options)
- [**$<COMPILE_LANG_AND_ID:language,compiler_ids>**](https://cmake.org/cmake/help/latest/manual/cmake-generator-expressions.7.html#genex:COMPILE_LANG_AND_ID)

## 具体知识点

### 1.

```cmake
add_library(tutorial_compiler_flags INTERFACE)
```

这行代码定义了一个名为 `tutorial_compiler_flags` 的接口库。接口库是一种特殊的库类型，它不包含任何源文件，而是用于传播编译选项、链接选项和其他属性给依赖它的目标。

### 2.

```cmake
target_compile_features(tutorial_compiler_flags INTERFACE cxx_std_11)
```

这行代码设置了 `tutorial_compiler_flags` 库的编译特性，要求使用 C++11 标准。`INTERFACE` 关键字表示这些编译特性只对依赖于 `tutorial_compiler_flags` 的其他目标可见。

### 3.

```cmake
set(gcc_like_cxx "$<COMPILE_LANG_AND_ID:CXX,ARMClang,AppleClang,Clang,GNU,LCC>")`
```

语法：$\<COMPILE_LANG_AND_ID:language,compiler_ids\>

当用于编译单元的语言与 `language` 匹配时为 1，并且`语言`编译器的 CMake 编译器 ID 与 `compiler_ids` 中的任何一个逗号分隔的条目匹配，否则为 `0`。此表达式是 `$<COMPILE_LANGUAGE：language>` 和 `$<LANG_COMPILER_ID:compiler_ids>` 的组合的缩写形式。此表达式可用于指定编译选项、编译定义以及包含目标中特定语言和编译器组合的源文件的目录。例如：

```cmake
add_executable(myapp main.cpp foo.c bar.cpp zot.cu)
target_compile_definitions(myapp
  PRIVATE $<$<COMPILE_LANG_AND_ID:CXX,AppleClang,Clang>:COMPILING_CXX_WITH_CLANG>
          $<$<COMPILE_LANG_AND_ID:CXX,Intel>:COMPILING_CXX_WITH_INTEL>
          $<$<COMPILE_LANG_AND_ID:C,Clang>:COMPILING_C_WITH_CLANG>
)
```

这行代码定义了一个变量 `gcc_like_cxx`，它是一个生成器表达式，用于检测当前使用的编译器是否是类似于 GCC 的编译器（包括 ARMClang, AppleClang, Clang, GNU, LCC）。如果条件满足，则该表达式的值为 `true`，否则为 `false`。

### 4.

```cmake
set(msvc_cxx "$<COMPILE_LANG_AND_ID:CXX,MSVC>")
```

这行代码定义了一个变量 `msvc_cxx`，它是一个生成器表达式，用于检测当前使用的编译器是否是 MSVC（Microsoft Visual C++）。如果条件满足，则该表达式的值为 `true`，否则为 `false`。

### 5.

```cmake
target_compile_options(tutorial_compiler_flags INTERFACE ... )
```

这行代码为 `tutorial_compiler_flags` 库设置编译选项。`INTERFACE` 关键字表示这些编译选项只对依赖于 `tutorial_compiler_flags` 的其他目标可见。

# step6 INSTALL

## 定义

“安装”是指将构建生成的文件（如可执行文件、库文件、头文件等）

复制到系统中的指定位置，以便在其他项目或系统中使用。

比如：通过cmake的配置文件可以生成.h文件。默认会在一个很深的目录结构中，

你可以通过安装的指令，指定他在哪个目录中生成，方便工程调用。

## 安装的作用

1. **分发和部署**：将构建生成的文件复制到系统中的标准位置，方便用户或其他项目使用。
2. **组织文件**：可以将不同的文件类型（如可执行文件、库文件、头文件等）安装到不同的目录，使文件结构更加清晰。
3. **跨平台支持**：CMake 的安装机制可以在不同操作系统上一致地工作，确保跨平台兼容性。

## 如何使用安装

### cmake指令说明

```cmake
set (CMAKE_INSTALL_PREFIX "${PROJECT_BINARY_DIR}/install")
install(TARGETS Tutorial DESTINATION bin)
message(STATUS "Installing TutorialConfig.h to ${CMAKE_INSTALL_PREFIX}/include")
install(FILES "${PROJECT_BINARY_DIR}/TutorialConfig.h" DESTINATION include)
message(STATUS "PROJECT_BINARY_DIR: ${PROJECT_BINARY_DIR}")
```

- **CMAKE_INSTALL_PREFIX**：默认安装的根目录

- **`TARGETS`**: 指定要安装的目标。在这里，`Tutorial` 是一个之前通过 `add_executable` 或 `add_library` 添加的目标。
- **`DESTINATION`**: 指定目标安装的路径。这里的 `bin` 表示目标将被安装到 `${CMAKE_INSTALL_PREFIX}/bin` 目录下。

- **`FILES`**: 指定要安装的文件列表。这里只有一个文件 `${PROJECT_BINARY_DIR}/TutorialConfig.h`。
- **`DESTINATION`**: 指定文件安装的路径。这里的 `include` 表示文件将被安装到 `${CMAKE_INSTALL_PREFIX}/include` 目录下。

这两个 `install` 命令的作用如下：

1. **`install(TARGETS Tutorial DESTINATION bin)`**:
   - 将 `Tutorial` 可执行文件或库安装到 `${CMAKE_INSTALL_PREFIX}/bin` 目录下。

2. **`install(FILES "${PROJECT_BINARY_DIR}/TutorialConfig.h" DESTINATION include)`**:
   - 将 `TutorialConfig.h` 头文件安装到 `${CMAKE_INSTALL_PREFIX}/include` 目录下。

### 执行安装

```
C:\Code\cmake_240913\build> cmake -S ..\Step6\ -B .
C:\Code\cmake_240913\build> cmake --build . --config Release
C:\Code\cmake_240913\build> cmake --install . --config Release
```

**C:\Code\cmake_240913\build>**：当前目录

-S：指定源文件目录

-B：指定cmake生成文件目录

install一定是已经编译生成目标文件了，才能使用安装，安装就是把一个文件，从a目录，移动到你想要的目录中。

**注意：在Windows下一定要自己指定CMAKE_INSTALL_PREFIX的值。默认值没有权限操作，会导致install失败。**



- **Linux 和 macOS**: 默认值通常是 `/usr/local`。
- **Windows**: 默认值通常是 `C:\Program Files\${PROJECT_NAME}` 或者 `C:\Program Files (x86)\${PROJECT_NAME}`，具体取决于系统架构。
- 运行cmake时：可以使用 这个命令指定DCMAKE_INSTALL_PREFIX的值-DCMAKE_INSTALL_PREFIX=/path/to/install 



# step6.1 ctest(测试)

## 用ctest有什么用？

ctest能够自动运行程序，验证运行结果，不用手动调用。

## ctest指令说明

```cmake
# enable testing
enable_testing()
```

- `enable_testing()`：启用测试功能，这是CTest的基础。它告诉CMake你将在项目中使用测试。

```cmake
# does the application run
add_test(NAME Runs COMMAND Tutorial 25)
```

- `add_test(NAME Runs COMMAND Tutorial 25)`：添加一个名为`Runs`的测试。这个测试会运行可执行文件`Tutorial`并传递参数`25`。如果`Tutorial`程序能够正常运行并且返回0状态码，那么这个测试就通过了。

```cmake
# does the usage message work?
add_test(NAME Usage COMMAND Tutorial)
set_tests_properties(Usage
  PROPERTIES PASS_REGULAR_EXPRESSION "Usage:.*number"
  )
```

- `add_test(NAME Usage COMMAND Tutorial)`：添加一个名为`Usage`的测试。这个测试会运行可执行文件`Tutorial`而不传递任何参数。
- `set_tests_properties(Usage PROPERTIES PASS_REG.Regular_EXPRESSION "Usage:.*number")`：设置`Usage`测试的属性，使其只有在输出中包含正则表达式`"Usage:.*number"`时才通过。这通常用于检查程序的帮助信息是否正确。

```cmake
# define a function to simplify adding tests
function(do_test target arg result)
  add_test(NAME Comp${arg} COMMAND ${target} ${arg})
  set_tests_properties(Comp${arg}
    PROPERTIES PASS_REGULAR_EXPRESSION ${result}
    )
endfunction()
```

- `function(do_test target arg result)`：

  定义一个名为`do_test`的函数，用于简化添加多个测试的过程。

- `add_test(NAME Comp${arg} COMMAND ${target} ${arg})`：

  添加一个名为`Comp${arg}`的测试，其中`${arg}`是传递给`target`的参数。

- `set_tests_properties(Comp${arg} PROPERTIES PASS_REGULAR_EXPRESSION ${result})`：设置`Comp${arg}`测试的属性，使其只有在输出中包含`${result}`时才通过。

```cmake
# do a bunch of result based tests
do_test(Tutorial 4 "4 is 2")
do_test(Tutorial 9 "9 is 3")
do_test(Tutorial 5 "5 is 2.236")
do_test(Tutorial 7 "7 is 2.645")
do_test(Tutorial 25 "25 is 5")
do_test(Tutorial -25 "-25 is (-nan|nan|0)")
do_test(Tutorial 0.0001 "0.0001 is 0.01")
```

- 这些调用`do_test`函数的语句分别添加了多个测试，每个测试都会运行`Tutorial`程序并传递不同的参数。测试的结果必须匹配指定的正则表达式才能通过。













































































